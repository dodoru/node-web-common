const co = require('co');
const Promise = require('bluebird');
const crypto = Promise.promisifyAll(require('crypto'));

// http://security.stackexchange.com/questions/110084/parameters-for-pbkdf2-for-password-hashing
const config = {
    hashBytes: 64,        // size of the generated hash (according to the chosen algorithm)
    saltBytes: 16,        // sise of the salt: larger salt means hashed passwords are more resistant to rainbow table
    iterations: 500000,    // tune so that hashing the password takes about 1 second
    algorithm: 'sha512',  //
    encoding: 'base64'   // hex is readable but base64 is shorter
};

/**
 * Hash a password using Node's asynchronous PBKDF2 (key derivation) function.
 *
 * Returns promise with a self-contained buffer encoded with config.encoding
 * that contains all the data needed to verify a password:
 -----------------------
 | SaltLen |     4     |
 |---------|-----------|
 | Salt    | saltBytes |
 |---------|-----------|
 | HashLen |     4     |
 |---------|-----------|
 | Salt    | hashBytes |
 -----------------------
 */
function encryptAsync(password) {
    return co(function* () {
        let salt = yield crypto.randomBytesAsync(config.saltBytes);
        let hash = yield crypto.pbkdf2Async(password, salt,
            config.iterations, config.hashBytes, config.algorithm);

        let array = new ArrayBuffer(hash.length + salt.length + 8);
        let hashframe = Buffer.from(array);

        // extract parameters from buffer
        hashframe.writeUInt32BE(salt.length, 0, true);
        hashframe.writeUInt32BE(config.iterations, 4, true);
        salt.copy(hashframe, 8);
        hash.copy(hashframe, salt.length + 8);
        return hashframe.toString(config.encoding);
    });
}

/**
 * Verify a password using Node's asynchronous pbkdf2 (key derivation) function.
 *
 * Accepts a hash and salt generated by hashPassword, and returns whether the
 * hash matched the password (as a resolved promise).
 */
function validateAsync(password, hashframe) {
    return co(function* () {
        if (!password || !hashframe) {
            return false;
        }

        // decode and extract hashing parameters
        hashframe = Buffer.from(hashframe, config.encoding);
        let saltBytes = hashframe.readUInt32BE(0);
        let hashBytes = hashframe.length - saltBytes - 8;
        let iterations = hashframe.readUInt32BE(4);
        let salt = hashframe.slice(8, saltBytes + 8);
        let hash = hashframe.slice(8 + saltBytes, saltBytes + hashBytes + 8);

        // verify the salt and hash against the password
        let correct_hash = yield crypto.pbkdf2Async(password,
            salt, iterations, hashBytes, config.algorithm);
        return correct_hash.equals(hash);
    });
}


module.exports = {
    encryptAsync: encryptAsync,
    validateAsync: validateAsync
};
